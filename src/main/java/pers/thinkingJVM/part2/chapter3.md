# 垃圾回收器和内存分配策略
## 判断对象“已死”两种方式
### 引用计数法
对于任意一个对象，添加一个引用计数器，每一次引用他的时候，计数器加1；每一次引用失效是，计数器减1
优点：虽然会产生额外的内存消耗，算法简单，易于计算（判定效率高）
存在的问题：需要解决循环引用或者相互引用的问题
### 可达性分析（GCRoot）
对一个对象而言，如果其余GCRoot之间没有任何有效链接相连，则意味着该对象是无效的，可以进行GC
#### 可作为GCRoot的对象：
1. 虚拟机栈引用的对象
1. 方法区中类的static量
1. 方法区中类的常量池中的final量
1. 本地方法栈中JNI引用的对象
1. 虚拟机内部引用，Class对象，一些常驻的异常对象，系统类加载器
1. 任意被同步锁持有的对象
## 引用的四种类型
强引用，软引用，弱引用，虚引用
## 方法区的回收：常量的回收和不再使用类型的回收
### 判断一个常量或类型是否不再使用的依据
1. 该类的所有实例都已被回收，不存在该类及其任何派生子类的实例
1. 加载该类的类加载器已被回收
1. 该类对应Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

### 对象已死？
#### 以可达性分析为例,至少要进行两次标记过程
 

## 垃圾回收算法
### 分代收集理论
1. 弱分代假说：绝大多数的对象都是朝生夕死的
1. 强分代假说：熬过越多次垃圾回收器的对象越难消亡
1. 跨代引用假说：跨代引用对对于同代引用来说占极其少数

### 垃圾收集器的分类
#### 部分收集 (Partial GC)

1. 新生代收集器 _young GC_
1. 老年代收集器 _old GC_

#### 整堆收集  _Full GC_
#### 混合收集  _Mixed GC_

### 垃圾收集算法

1. 标记-清除    
    优点：处理极快，消耗资源小。    
    缺点：会产生大量的内存碎片，如果存在大对象写入内存操作，可能频繁触发GC

1. 标记-复制    
    优点：不会产生内存碎片，处理很快    
    缺点：会有一半的空间用于预复制区，浪费内存资源     
     _改进版_：由于新生代存在“朝生夕死”的特点，可以将新生代分成一块较大的Eden区，和两块较小的survivor区；
     通常只使用Eden和其中一块Survivor,当进行GC操作时,将GC后存活的对象存入另一块Survivor中；Eden和Survivor大小默认为8:1    
     _改进版存在的问题_：当正在使用的Survivor满了之后需要向老年代临时获取内存    
     ParNew、Serial 都使用此方法

1. 标记-整理   
    由于老年代的对象的特性，如果执行“标记-复制”算法会占用系统很大的资源，而且运行效率极慢，老年代一般使用基于“标记-整理”算法的
    GC    
    “标记-整理”和“标记-复制”的区别在于前者是先标记然后进行直接回收，后者是先标记然后移动的。    
    “标记-整理”算法是一种优缺点并存的决策。
    



















