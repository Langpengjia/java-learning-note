### 线程安全与锁优化     
当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下得调度和交替执行，也不用进行而外的同步，
或者在调用方进行任何的协调操作，调用这个对象的行为可以获得正确的结果，那就称这个对象是线程安全的。    

#### 操作共享数据的类别    
不可变对象  绝对线程安全  相对线程安全  线程兼容  线程对立（死锁的原因）

##### 线程安全的实现方法    
  
###### 互斥同步/阻塞同步（悲观并发策略）      
多个线程在访问共享数据时，保证共享数据在同一时刻只被一个（或一些，当使用信号量）线程访问    
* sychronized（可重入锁）      
    编译之后会在代码块前后插入 monitorenter 和 monitorexit 指令    
* ReentrantLock(可重入锁，支持等待和中断，可实现公平，可实现多条件)    

###### 非阻塞同步/CAS(乐观锁)    
     
原子类的作用  核心：UnSafe类 jdk9之前由系统类加载器加载，不允许自定义使用    
优点：简单且高效    
缺点：ABA 问题；可以加入带有标记的原子引用类AtomicSampledRefence ，但是一般上不会碰到ABA问题，否则建议使用阻塞同步解决     
###### 无同步方案     
可重入代码/纯代码     

#### 锁优化     
    适应性自旋  锁消除  锁膨胀（锁粗化）  轻量级锁  偏向锁    
  
    







 
    













